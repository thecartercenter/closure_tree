{"name":"Closure tree","tagline":"Easily and efficiently make your ActiveRecord model support hierarchies","body":"# Closure Tree\r\n\r\n### Closure_tree lets your ActiveRecord models act as nodes in a [tree data structure](http://en.wikipedia.org/wiki/Tree_%28data_structure%29)\r\n\r\nCommon applications include modeling hierarchical data, like tags, page graphs in CMSes,\r\nand tracking user referrals.\r\n\r\n[![Build Status](https://secure.travis-ci.org/mceachen/closure_tree.png?branch=master)](http://travis-ci.org/mceachen/closure_tree)\r\n[![Gem Version](https://badge.fury.io/rb/closure_tree.png)](http://rubygems.org/gems/closure_tree)\r\n[![Code Climate](https://codeclimate.com/github/mceachen/closure_tree.png)](https://codeclimate.com/github/mceachen/closure_tree)\r\n[![Dependency Status](https://gemnasium.com/mceachen/closure_tree.png)](https://gemnasium.com/mceachen/closure_tree)\r\n\r\nDramatically more performant than\r\n[ancestry](https://github.com/stefankroes/ancestry) and\r\n[acts_as_tree](https://github.com/amerine/acts_as_tree), and even more\r\nawesome than [awesome_nested_set](https://github.com/collectiveidea/awesome_nested_set/),\r\nclosure_tree has some great features:\r\n\r\n* __Best-in-class select performance__:\r\n  * Fetch your whole ancestor lineage in 1 SELECT.\r\n  * Grab all your descendants in 1 SELECT.\r\n  * Get all your siblings in 1 SELECT.\r\n  * Fetch all [descendants as a nested hash](#nested-hashes) in 1 SELECT.\r\n  * [Find a node by ancestry path](#find_or_create_by_path) in 1 SELECT.\r\n* __Best-in-class mutation performance__:\r\n  * 2 SQL INSERTs on node creation\r\n  * 3 SQL INSERT/UPDATEs on node reparenting\r\n* __Support for [concurrency](#concurrency)__ (using [with_advisory_lock](https://github.com/mceachen/with_advisory_lock))\r\n* __Support for Rails 3.2, 4.0, and 4.1__\r\n* __Support for Ruby 1.9, 2.1, and jRuby 1.6.13__\r\n* Support for reparenting children (and all their descendants)\r\n* Support for [single-table inheritance (STI)](#sti) within the hierarchy\r\n* ```find_or_create_by_path``` for [building out heterogeneous hierarchies quickly and conveniently](#find_or_create_by_path)\r\n* Support for [deterministic ordering](#deterministic-ordering)\r\n* Support for [preordered](http://en.wikipedia.org/wiki/Tree_traversal#Pre-order) traversal of descendants\r\n* Support for rendering trees in [DOT format](http://en.wikipedia.org/wiki/DOT_(graph_description_language)), using [Graphviz](http://www.graphviz.org/)\r\n* Excellent [test coverage](#testing) in a comprehensive variety of environments\r\n\r\nSee [Bill Karwin](http://karwin.blogspot.com/)'s excellent\r\n[Models for hierarchical data presentation](http://www.slideshare.net/billkarwin/models-for-hierarchical-data)\r\nfor a description of different tree storage algorithms.\r\n\r\n## Table of Contents\r\n\r\n- [Installation](#installation)\r\n- [Usage](#usage)\r\n- [Accessing Data](#accessing-data)\r\n- [Polymorphic hierarchies with STI](#polymorphic-hierarchies-with-sti)\r\n- [Deterministic ordering](#deterministic-ordering)\r\n- [Concurrency](#concurrency)\r\n- [FAQ](#faq)\r\n- [Testing](#testing)\r\n- [Change log](#change-log)\r\n\r\n## Installation\r\n\r\nNote that closure_tree only supports Rails 3.2 and later, and has test coverage for MySQL, PostgreSQL, and SQLite.\r\n\r\n1.  Add `gem 'closure_tree'` to your Gemfile \r\n\r\n2.  Run `bundle install`\r\n\r\n3.  Add `acts_as_tree` to your hierarchical model:\r\n\r\n    ```ruby\r\n    class Tag < ActiveRecord::Base\r\n      acts_as_tree\r\n    end\r\n    ```\r\n\r\n    Make sure you check out the [large number options](#available-options) that `acts_as_tree` accepts.\r\n    \r\n    Make sure you add `acts_as_tree` **after** `attr_accessible` and\r\n    `self.table_name =` lines in your model.\r\n\r\n4.  Add a migration to add a `parent_id` column to the hierarchical model.\r\n    You may want to also [add a column for deterministic ordering of children](#sort_order), but that's optional.\r\n\r\n    ```ruby\r\n    class AddParentIdToTag < ActiveRecord::Migration\r\n      def change\r\n        add_column :tag, :parent_id, :integer\r\n      end\r\n    end\r\n    ```\r\n\r\n    The column must be nullable. Root nodes have a `NULL` `parent_id`.\r\n\r\n5.  Run `rails g closure_tree:migration tag` (and replace `tag` with your model name)\r\n    to create the closure tree table for your model.\r\n\r\n    By default the table name will be the model's table name, followed by\r\n    \"_hierarchies\". Note that by calling ```acts_as_tree```, a \"virtual model\" (in this case, ```TagHierarchy```)\r\n    will be created dynamically. You don't need to create it.\r\n\r\n6.  Run `rake db:migrate`\r\n\r\n7.  If you're migrating from another system where your model already has a\r\n    `parent_id` column, run `Tag.rebuild!` and your\r\n    `tag_hierarchies` table will be truncated and rebuilt.\r\n\r\n    If you're starting from scratch you don't need to call `rebuild!`.\r\n\r\n## Usage\r\n\r\n### Creation\r\n\r\nCreate a root node:\r\n\r\n```ruby\r\ngrandparent = Tag.create(name: 'Grandparent')\r\n```\r\n\r\nChild nodes are created by appending to the children collection:\r\n\r\n```ruby\r\nparent = grandparent.children.create(name: 'Parent')\r\n```\r\n\r\nOr by appending to the children collection:\r\n\r\n```ruby\r\nchild2 = Tag.new(name: 'Second Child')\r\nparent.children << child2\r\n```\r\n\r\nOr by calling the \"add_child\" method:\r\n\r\n```ruby\r\nchild3 = Tag.new(name: 'Third Child')\r\nparent.add_child child3\r\n```\r\n\r\nThen:\r\n\r\n```ruby\r\ngrandparent.self_and_descendants.collect(&:name)\r\n=> [\"Grandparent\", \"Parent\", \"First Child\", \"Second Child\", \"Third Child\"]\r\n\r\nchild1.ancestry_path\r\n=> [\"Grandparent\", \"Parent\", \"First Child\"]\r\n```\r\n\r\n### find_or_create_by_path\r\n\r\nYou can `find` as well as `find_or_create` by \"ancestry paths\".\r\n\r\nIf you provide an array of strings to these methods, they reference the `name` column in your \r\nmodel, which can be overridden with the `:name_column` option provided to `acts_as_tree`.\r\n\r\n```ruby\r\nchild = Tag.find_or_create_by_path(%w[grandparent parent child])\r\n```\r\n\r\nAs of v5.0.0, `find_or_create_by_path` can also take an array of attribute hashes:\r\n\r\n```ruby\r\nchild = Tag.find_or_create_by_path([\r\n  {name: 'Grandparent', title: 'Sr.'},\r\n  {name: 'Parent', title: 'Mrs.'},\r\n  {name: 'Child', title: 'Jr.'}\r\n])\r\n```\r\n\r\nIf you're using STI, The attribute hashes can contain the `sti_name` and things work as expected:\r\n\r\n```ruby\r\nchild = Label.find_or_create_by_path([\r\n  {type: 'DateLabel', name: '2014'},\r\n  {type: 'DateLabel', name: 'August'},\r\n  {type: 'DateLabel', name: '5'},\r\n  {type: 'EventLabel', name: 'Visit the Getty Center'}\r\n])\r\n```\r\n\r\n### Moving nodes around the tree\r\n\r\nNodes can be moved around to other parents, and closure_tree moves the node's descendancy to the\r\nnew parent for you:\r\n\r\n```ruby\r\nd = Tag.find_or_create_by_path %w[a b c d]\r\nh = Tag.find_or_create_by_path %w[e f g h]\r\ne = h.root\r\nd.add_child(e) # \"d.children << e\" would work too, of course\r\nh.ancestry_path\r\n=> [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\"]\r\n```\r\n\r\n### Nested hashes\r\n\r\n```hash_tree``` provides a method for rendering a subtree as an\r\nordered nested hash:\r\n\r\n```ruby\r\nb = Tag.find_or_create_by_path %w(a b)\r\na = b.parent\r\nb2 = Tag.find_or_create_by_path %w(a b2)\r\nd1 = b.find_or_create_by_path %w(c1 d1)\r\nc1 = d1.parent\r\nd2 = b.find_or_create_by_path %w(c2 d2)\r\nc2 = d2.parent\r\n\r\nTag.hash_tree\r\n=> {a => {b => {c1 => {d1 => {}}, c2 => {d2 => {}}}, b2 => {}}}\r\n\r\nTag.hash_tree(:limit_depth => 2)\r\n=> {a => {b => {}, b2 => {}}}\r\n\r\nb.hash_tree\r\n=> {b => {c1 => {d1 => {}}, c2 => {d2 => {}}}}\r\n\r\nb.hash_tree(:limit_depth => 2)\r\n=> {b => {c1 => {}, c2 => {}}}\r\n```\r\n\r\n**If your tree is large (or might become so), use :limit_depth.**\r\n\r\nWithout this option, ```hash_tree``` will load the entire contents of that table into RAM. Your\r\nserver may not be happy trying to do this.\r\n\r\nHT: [ancestry](https://github.com/stefankroes/ancestry#arrangement) and [elhoyos](https://github.com/mceachen/closure_tree/issues/11)\r\n\r\n### Graph visualization\r\n\r\n```to_dot_digraph``` is suitable for passing into [Graphviz](http://www.graphviz.org/).\r\n\r\nFor example, for the above tree, write out the DOT file with ruby:\r\n```ruby\r\nFile.open(\"example.dot\", \"w\") { |f| f.write(Tag.root.to_dot_digraph) }\r\n```\r\nThen, in a shell, ```dot -Tpng example.dot > example.png```, which produces:\r\n\r\n![Example tree](https://raw.github.com/mceachen/closure_tree/master/img/example.png)\r\n\r\nIf you want to customize the label value, override the ```#to_digraph_label``` instance method in your model.\r\n\r\nJust for kicks, this is the test tree I used for proving that preordered tree traversal was correct:\r\n\r\n![Preordered test tree](https://raw.github.com/mceachen/closure_tree/master/img/preorder.png)\r\n\r\n### Available options\r\n\r\nWhen you include ```acts_as_tree``` in your model, you can provide a hash to override the following defaults:\r\n\r\n* ```:parent_column_name``` to override the column name of the parent foreign key in the model's table. This defaults to \"parent_id\".\r\n* ```:hierarchy_class_name``` to override the hierarchy class name. This defaults to the singular name of the model + \"Hierarchy\", like ```TagHierarchy```.\r\n* ```:hierarchy_table_name``` to override the hierarchy table name. This defaults to the singular name of the model + \"_hierarchies\", like ```tag_hierarchies```.\r\n* ```:dependent``` determines what happens when a node is destroyed. Defaults to ```nullify```.\r\n    * ```:nullify``` will simply set the parent column to null. Each child node will be considered a \"root\" node. This is the default.\r\n    * ```:delete_all``` will delete all descendant nodes (which circumvents the destroy hooks)\r\n    * ```:destroy``` will destroy all descendant nodes (which runs the destroy hooks on each child node)\r\n* ```:name_column``` used by #```find_or_create_by_path```, #```find_by_path```, and ```ancestry_path``` instance methods. This is primarily useful if the model only has one required field (like a \"tag\").\r\n* ```:order``` used to set up [deterministic ordering](#deterministic-ordering)\r\n* ```:touch``` delegates to the `belongs_to` annotation for the parent, so `touch`ing cascades to all children (the performance of this for deep trees isn't currently optimal).\r\n\r\n## Accessing Data\r\n\r\n### Class methods\r\n\r\n* ```Tag.root``` returns an arbitrary root node\r\n* ```Tag.roots``` returns all root nodes\r\n* ```Tag.leaves``` returns all leaf nodes\r\n* ```Tag.hash_tree``` returns an [ordered, nested hash](#nested-hashes) that can be depth-limited.\r\n* ```Tag.find_by_path(path, attributes)``` returns the node whose name path is ```path```. See (#find_or_create_by_path).\r\n* ```Tag.find_or_create_by_path(path, attributes)``` returns the node whose name path is ```path```, and will create the node if it doesn't exist already.See (#find_or_create_by_path).\r\n* ```Tag.find_all_by_generation(generation_level)``` returns the descendant nodes who are ```generation_level``` away from a root. ```Tag.find_all_by_generation(0)``` is equivalent to ```Tag.roots```.\r\n* ```Tag.with_ancestor(ancestors)``` scopes to all descendants whose ancestor is in the given list.\r\n\r\n### Instance methods\r\n\r\n* ```tag.root``` returns the root for this node\r\n* ```tag.root?``` returns true if this is a root node\r\n* ```tag.child?``` returns true if this is a child node. It has a parent.\r\n* ```tag.leaf?``` returns true if this is a leaf node. It has no children.\r\n* ```tag.leaves``` is scoped to all leaf nodes in self_and_descendants.\r\n* ```tag.depth``` returns the depth, or \"generation\", for this node in the tree. A root node will have a value of 0.\r\n* ```tag.parent``` returns the node's immediate parent. Root nodes will return nil.\r\n* ```tag.children``` is a ```has_many``` of immediate children (just those nodes whose parent is the current node).\r\n* ```tag.child_ids``` is an array of the IDs of the children.\r\n* ```tag.ancestors``` is a ordered scope of [ parent, grandparent, great grandparent, â€¦ ]. Note that the size of this array will always equal ```tag.depth```.\r\n* ```tag.ancestor_ids``` is an array of the IDs of the ancestors.\r\n* ```tag.self_and_ancestors``` returns a scope containing self, parent, grandparent, great grandparent, etc.\r\n* ```tag.self_and_ancestors_ids``` returns IDs containing self, parent, grandparent, great grandparent, etc.\r\n* ```tag.siblings``` returns a scope containing all nodes with the same parent as ```tag```, excluding self.\r\n* ```tag.sibling_ids``` returns an array of the IDs of the siblings.\r\n* ```tag.self_and_siblings``` returns a scope containing all nodes with the same parent as ```tag```, including self.\r\n* ```tag.descendants``` returns a scope of all children, childrens' children, etc., excluding self ordered by depth.\r\n* ```tag.descendant_ids``` returns an array of the IDs of the descendants.\r\n* ```tag.self_and_descendants``` returns a scope of self, all children, childrens' children, etc., ordered by depth.\r\n* ```tag.self_and_descendant_ids``` returns IDs of self, all children, childrens' children, etc., ordered by depth.\r\n* ```tag.hash_tree``` returns an [ordered, nested hash](#nested-hashes) that can be depth-limited.\r\n* ```tag.find_by_path(path)``` returns the node whose name path *from ```tag```* is ```path```. See (#find_or_create_by_path).\r\n* ```tag.find_or_create_by_path(path)``` returns the node whose name path *from ```tag```* is ```path```, and will create the node if it doesn't exist already.See (#find_or_create_by_path).\r\n* ```tag.find_all_by_generation(generation_level)``` returns the descendant nodes who are ```generation_level``` away from ```tag```.\r\n    * ```tag.find_all_by_generation(0).to_a``` == ```[tag]```\r\n    * ```tag.find_all_by_generation(1)``` == ```tag.children```\r\n    * ```tag.find_all_by_generation(2)``` will return the tag's grandchildren, and so on.\r\n* ```tag.destroy``` will destroy a node and do <em>something</em> to its children, which is determined by the ```:dependent``` option passed to ```acts_as_tree```.\r\n\r\n## Polymorphic hierarchies with STI\r\n\r\nPolymorphic models using single table inheritance (STI) are supported:\r\n\r\n1. Create a db migration that adds a String ```type``` column to your model\r\n2. Subclass the model class. You only need to add ```acts_as_tree``` to your base class:\r\n\r\n```ruby\r\nclass Tag < ActiveRecord::Base\r\n  acts_as_tree\r\nend\r\nclass WhenTag < Tag ; end\r\nclass WhereTag < Tag ; end\r\nclass WhatTag < Tag ; end\r\n```\r\n\r\nPlease note that Rails (<= 3.2) doesn't handle polymorphic associations correctly if\r\nyou use the ```:type``` attribute, so **this doesn't work**:\r\n\r\n```ruby\r\n# BAD: ActiveRecord ignores the :type attribute:\r\nroot.children.create(:name => \"child\", :type => \"WhenTag\")\r\n```\r\n\r\nInstead, use either ```.add_child``` or ```children <<```:\r\n\r\n```ruby\r\n# GOOD!\r\na = Tag.create!(:name => \"a\")\r\nb = WhenTag.new(:name => \"b\")\r\na.children << b\r\nc = WhatTag.new(:name => \"c\")\r\nb.add_child(c)\r\n```\r\n\r\nSee [issue 43](https://github.com/mceachen/closure_tree/issues/43) for more information.\r\n\r\n## Deterministic ordering\r\n\r\nBy default, children will be ordered by your database engine, which may not be what you want.\r\n\r\nIf you want to order children alphabetically, and your model has a ```name``` column, you'd do this:\r\n\r\n```ruby\r\nclass Tag < ActiveRecord::Base\r\n  acts_as_tree :order => 'name'\r\nend\r\n```\r\n\r\nIf you want a specific order, add a new integer column to your model in a migration:\r\n\r\n```ruby\r\nt.integer :sort_order\r\n```\r\n\r\nand in your model:\r\n\r\n```ruby\r\nclass OrderedTag < ActiveRecord::Base\r\n  acts_as_tree :order => 'sort_order'\r\nend\r\n```\r\n\r\nWhen you enable ```order```, you'll also have the following new methods injected into your model:\r\n\r\n* ```tag.siblings_before``` is a scope containing all nodes with the same parent as ```tag```,\r\n  whose sort order column is less than ```self```. These will be ordered properly, so the ```last```\r\n  element in scope will be the sibling immediately before ```self```\r\n* ```tag.siblings_after``` is a scope containing all nodes with the same parent as ```tag```,\r\n  whose sort order column is more than ```self```. These will be ordered properly, so the ```first```\r\n  element in scope will be the sibling immediately \"after\" ```self```\r\n\r\nIf your ```order``` column is an integer attribute, you'll also have these:\r\n\r\n* The class method ```#roots_and_descendants_preordered```, which returns all nodes in your tree,\r\n  [pre-ordered](http://en.wikipedia.org/wiki/Tree_traversal#Pre-order).\r\n\r\n* ```node1.self_and_descendants_preordered``` which will return descendants,\r\n  [pre-ordered](http://en.wikipedia.org/wiki/Tree_traversal#Pre-order).\r\n\r\n* ```node1.append_child(node2)``` (which is an alias to ```add_child```), which will\r\n  1. set ```node2```'s parent to ```node1```\r\n  2. set ```node2```'s sort order to place node2 last in the ```children``` array\r\n\r\n* ```node1.prepend_child(node2)``` which will\r\n  1. set ```node2```'s parent to ```node1```\r\n  2. set ```node2```'s sort order to place node2 first in the ```children``` array\r\n     Note that all of ```node1```'s children's sort_orders will be incremented\r\n\r\n* ```node1.prepend_sibling(node2)``` which will\r\n  1. set ```node2``` to the same parent as ```node1```,\r\n  2. set ```node2```'s order column to 1 less than ```node1```'s value, and\r\n  3. decrement the order_column of all children of node1's parents whose order_column is <>>= node2's new value by 1.\r\n\r\n* ```node1.append_sibling(node2)``` which will\r\n  1. set ```node2``` to the same parent as ```node1```,\r\n  2. set ```node2```'s order column to 1 more than ```node1```'s value, and\r\n  3. increment the order_column of all children of node1's parents whose order_column is >= node2's new value by 1.\r\n\r\n```ruby\r\n\r\nroot = OrderedTag.create(name: 'root')\r\na = root.append_child(Label.new(name: 'a'))\r\nb = OrderedTag.create(name: 'b')\r\nc = OrderedTag.create(name: 'c')\r\n\r\n# We have to call 'root.reload.children' because root won't be in sync with the database otherwise:\r\n\r\na.append_sibling(b)\r\nroot.reload.children.pluck(:name)\r\n=> [\"a\", \"b\"]\r\n\r\na.prepend_sibling(b)\r\nroot.reload.children.pluck(:name)\r\n=> [\"b\", \"a\"]\r\n\r\na.append_sibling(c)\r\nroot.reload.children.pluck(:name)\r\n=> [\"b\", \"a\", \"c\"]\r\n\r\nb.append_sibling(c)\r\nroot.reload.children.pluck(:name)\r\n=> [\"b\", \"c\", \"a\"]\r\n```\r\n\r\n## Concurrency\r\n\r\nSeveral methods, especially ```#rebuild``` and ```#find_or_create_by_path```, cannot run concurrently correctly.\r\n```#find_or_create_by_path```, for example, may create duplicate nodes.\r\n\r\nDatabase row-level locks work correctly with PostgreSQL, but MySQL's row-level locking is broken, and\r\nerroneously reports deadlocks where there are none. To work around this, and have a consistent implementation\r\nfor both MySQL and PostgreSQL, [with_advisory_lock](https://github.com/mceachen/with_advisory_lock)\r\nis used automatically to ensure correctness.\r\n\r\nIf you are already managing concurrency elsewhere in your application, and want to disable the use\r\nof with_advisory_lock, pass ```:with_advisory_lock => false``` in the options hash:\r\n\r\n```ruby\r\nclass Tag\r\n  acts_as_tree :with_advisory_lock => false\r\nend\r\n```\r\n\r\nNote that you *will eventually have data corruption* if you disable advisory locks, write to your\r\ndatabase with multiple threads, and don't provide an alternative mutex.\r\n\r\n\r\n## FAQ\r\n\r\n### Are there any how-to articles on how to use this gem?\r\n\r\nYup! [Ilya Bodrov](https://github.com/bodrovis) wrote [Nested Comments with Rails](http://www.sitepoint.com/nested-comments-rails/).\r\n\r\n### Does this work well with ```#default_scope```?\r\n\r\nNo. Please see [issue 86](https://github.com/mceachen/closure_tree/issues/86) for details.\r\n\r\n### Does this gem support multiple parents?\r\n\r\nNo. This gem's API is based on the assumption that each node has either 0 or 1 parent.\r\n\r\nThe underlying closure tree structure will support multiple parents, but there would be many\r\nbreaking-API changes to support it. I'm open to suggestions and pull requests.\r\n\r\n### How do I use this with test fixtures?\r\n\r\nTest fixtures aren't going to be running your ```after_save``` hooks after inserting all your\r\nfixture data, so you need to call ```.rebuild!``` before your test runs. There's an example in\r\nthe spec ```tag_spec.rb```:\r\n\r\n```ruby\r\n  describe \"Tag with fixtures\" do\r\n    fixtures :tags\r\n    before :each do\r\n      Tag.rebuild! # <- required if you use fixtures\r\n    end\r\n```\r\n`\r\n**However, if you're just starting with Rails, may I humbly suggest you adopt a factory library**,\r\nrather than using fixtures? [Lots of people have written about this already](https://www.google.com/search?q=fixtures+versus+factories).\r\n\r\n### There are many ```lock-*``` files in my project directory after test runs\r\n\r\nThis is expected if you aren't using MySQL or Postgresql for your tests.\r\n\r\nSQLite doesn't have advisory locks, so we resort to file locking, which will only work\r\nif the ```FLOCK_DIR``` is set consistently for all ruby processes.\r\n\r\nIn your ```spec_helper.rb``` or ```minitest_helper.rb```, add a ```before``` and ```after``` block:\r\n\r\n```ruby\r\nbefore do\r\n  ENV['FLOCK_DIR'] = Dir.mktmpdir\r\nend\r\n\r\nafter do\r\n  FileUtils.remove_entry_secure ENV['FLOCK_DIR']\r\nend\r\n```\r\n\r\n## Testing with Closure Tree\r\n\r\nClosure tree comes with some RSpec2/3 matchers which you may use for your tests:\r\n\r\n```ruby\r\nrequire 'spec_helper'\r\nrequire 'closure_tree/test/matcher'\r\n\r\ndescribe Category do\r\n # Should syntax\r\n it { should be_a_closure_tree }\r\n # Expect syntax\r\n it { is_expected.to be_a_closure_tree }\r\nend\r\n\r\ndescribe Label do\r\n # Should syntax\r\n it { should be_a_closure_tree.ordered }\r\n # Expect syntax\r\n it { is_expected.to be_a_closure_tree.ordered }\r\nend\r\n\r\ndescribe TodoList::Item do\r\n # Should syntax\r\n it { should be_a_closure_tree.ordered(:priority_order) }\r\n # Expect syntax\r\n it { is_expected.to be_a_closure_tree.ordered(:priority_order) }\r\nend\r\n\r\n```\r\n\r\n## Testing\r\n\r\nClosure tree is [tested under every valid combination](http://travis-ci.org/#!/mceachen/closure_tree) of\r\n\r\n* Ruby 1.9.3, 2.1.2 (and sometimes head)\r\n* Rubinius 2.2.1+ (and sometimes head)\r\n* jRuby 1.9mode (and sometimes head)\r\n* The latest Rails 3.2, 4.0, 4.1 and master branches\r\n* Concurrency tests for MySQL and PostgreSQL. SQLite is tested in a single-threaded environment.\r\n\r\nAssuming you're using [rbenv](https://github.com/sstephenson/rbenv), you can use ```tests.sh``` to\r\nrun the test matrix locally.\r\n\r\n## Change log\r\n\r\nSee the [change log](https://github.com/mceachen/closure_tree/blob/master/CHANGELOG.md).\r\n\r\n## Thanks to\r\n\r\n* The more than 20 engineers around the world that have contributed their time and code to this gem\r\n  (see the [changelog](https://github.com/mceachen/closure_tree/blob/master/CHANGELOG.md)!)\r\n* https://github.com/collectiveidea/awesome_nested_set\r\n* https://github.com/patshaughnessy/class_factory\r\n* JetBrains, which provides an [open-source license](http://www.jetbrains.com/ruby/buy/buy.jsp#openSource) to\r\n  [RubyMine](http://www.jetbrains.com/ruby/features/) for the development of this project.\r\n","google":"UA-38750440-1","note":"Don't delete this file! It's used internally to help with page regeneration."}